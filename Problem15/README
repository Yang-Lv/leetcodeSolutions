时间：2016/5/12   
题目：leetcode_Problem15小节
这道题目是twoSum问题的变形。
想到一个这道题的算法并不复杂，可以借助map,sort等stl函数。
一开始，我想到了最笨的方法，就是固定第一个数和第二个数，判断是否存在第三个数的方法，在这里面我借助了multimap，本机运行通过了，但是OJ上意料中的Time Limit Exceeded。后来，尝试固定第一个数后，使用twoSum的代码，发现问题依旧。看来OJ是真的要和我较劲了。
实在没办法，我就看了下Disscuss区，别人的做法。很多算法都几乎一样，找到一个OJ通过的，发现了关键所在：首先，算法模式不变，依旧是固定第一个数，后使用twoSum的方法，所以必然会是二重循环；其次，我们需要找到算法中很多可以避免的计算，将其Pass掉。比如说，当前第一个数是nums[0]=-1,那如果nums[1]==nums[0],则可以Pass。因为在nums[0]时我们就已经把第一个数-1的情况全部找到了；再者，对于第二个数和第三个数，假设是nums[j]和nums[k]吧，我们需要判断nums[j]后面的数是否与nums[j]相等，如果相等则j++,直到nums[j+1]不等于nums[j];同理对与nums[k]，则需要判断num[k-1]是否与nums[k]相等，相等则k--....如此，则就可以大幅减少算法的时间复杂度。
总的来说，做这道题我们需要关注算法实现的细节，搞清楚其中哪些是可以避免的计算，从而提高算法效率。
